import abc
import typing

from pip._vendor.tenacity import _utils

if typing.TYPE_CHECKING:
    import threading
    from pip._vendor.tenacity import RetryCallState


class StopBase(abc.ABC):
    """Abstract base class for stop strategies."""

    @abc.abstractmethod
    def __call__(self, retry_state: "RetryCallState") -> bool:
        pass

    def __and__(self, other: "StopBase") -> "StopAll":
        if not isinstance(other, StopBase):
            raise TypeError("Operand must be an instance of StopBase")
        return StopAll(self, other)

    def __or__(self, other: "StopBase") -> "StopAny":
        if not isinstance(other, StopBase):
            raise TypeError("Operand must be an instance of StopBase")
        return StopAny(self, other)


StopBaseT = typing.Union[StopBase, typing.Callable[["RetryCallState"], bool]]


class StopAny(StopBase):
    """Stop if any of the stop condition is valid."""

    def __init__(self, *stops: StopBase) -> None:
        if not all(isinstance(stop, StopBase) for stop in stops):
            raise TypeError("All stops must be instances of StopBase")
        self.stops = stops

    def __call__(self, retry_state: "RetryCallState") -> bool:
        return any(x(retry_state) for x in self.stops)


class StopAll(StopBase):
    """Stop if all the stop conditions are valid."""

    def __init__(self, *stops: StopBase) -> None:
        if not all(isinstance(stop, StopBase) for stop in stops):
            raise TypeError("All stops must be instances of StopBase")
        self.stops = stops

    def __call__(self, retry_state: "RetryCallState") -> bool:
        return all(x(retry_state) for x in self.stops)


class _StopNever(StopBase):
    """Never stop."""

    def __call__(self, retry_state: "RetryCallState") -> bool:
        return False


stop_never = _StopNever()


class StopWhenEventSet(StopBase):
    """Stop when the given event is set."""

    def __init__(self, event: "threading.Event") -> None:
        if not isinstance(event, threading.Event):
            raise TypeError("Event must be an instance of threading.Event")
        self.event = event

    def __call__(self, retry_state: "RetryCallState") -> bool:
        return self.event.is_set()


class StopAfterAttempt(StopBase):
    """Stop when the previous attempt >= max_attempt."""

    def __init__(self, max_attempt_number: int) -> None:
        if not isinstance(max_attempt_number, int) or max_attempt_number < 1:
            raise ValueError("max_attempt_number must be a positive integer")
        self.max_attempt_number = max_attempt_number

    def __call__(self, retry_state: "RetryCallState") -> bool:
        return retry_state.attempt_number >= self.max_attempt_number


class StopAfterDelay(StopBase):
    """Stop when the time from the first attempt >= limit."""

    def __init__(self, max_delay: _utils.time_unit_type) -> None:
        self.max_delay = _utils.to_seconds(max_delay)

    def __call__(self, retry_state: "RetryCallState") -> bool:
        if retry_state.seconds_since_start is None:
            raise RuntimeError("__call__() called but seconds_since_start is not set")
        return retry_state.seconds_since_start >= self.max_delay
