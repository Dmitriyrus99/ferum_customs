--- a/ferum_customs/doctype/payroll_entry_custom/payroll_entry_custom.py
+++ b/ferum_customs/doctype/payroll_entry_custom/payroll_entry_custom.py
@@ -7,15 +7,6 @@
 
 import frappe
 from frappe.model.document import Document
-
-# from typing import TYPE_CHECKING
-
-
-# from frappe import _ # Если будут пользовательские сообщения
-
-# if TYPE_CHECKING:
-# pass
-
 
 class PayrollEntryCustom(Document):  # type: ignore[misc]
     total_payable: float | None
@@ -38,30 +29,21 @@
         self._round_total_deductions()
         self._calculate_net_payable()
 
-        # Логика из оригинального файла (payroll_entry_custom.py):
-        # if self.total_payable is not None:
-        #     self.total_payable = round(float(self.total_payable), 2)
-        # Эта логика теперь в _round_total_payable()
-
     def _round_total_payable(self) -> None:
         """
         Округляет поле `total_payable` до двух знаков после запятой, если оно установлено и является числом.
         """
-        if self.get("total_payable") is not None:
+        if self.total_payable is not None:
             try:
-                # Преобразуем в float перед округлением, на случай если это строка или Decimal
-                payable_float = float(self.total_payable or 0.0)
+                payable_float = float(self.total_payable)
                 self.total_payable = round(payable_float, 2)
             except (ValueError, TypeError):
-                # Если значение не может быть преобразовано в float, логируем или выбрасываем ошибку.
-                # В данном случае, просто не изменяем значение, если оно не числовое.
-                # Это может быть обработано другими валидациями (например, тип поля Currency).
                 pass  # Или frappe.log_error(...)
 
     def _round_total_deductions(self) -> None:
-        if self.get("total_deductions") is not None:
+        if self.total_deductions is not None:
             try:
-                deductions_float = float(self.total_deductions or 0.0)
+                deductions_float = float(self.total_deductions)
                 self.total_deductions = round(deductions_float, 2)
             except (ValueError, TypeError):
                 pass
@@ -72,7 +54,6 @@
             ded = float(self.total_deductions or 0.0)
             self.net_payable = round(pay - ded, 2)
         except (ValueError, TypeError):
-            # Если не удалось привести к числам, не задаем значение
             self.net_payable = None
 
     def before_save(self) -> None:
@@ -102,9 +83,9 @@
                 exc_info=True,
             )
 
-        base_salary = float(self.get("base_salary", 0.0) or 0.0)
-        additional_pay = float(self.get("additional_pay", 0.0) or 0.0)
-        total_deduction = float(self.get("total_deduction", 0.0) or 0.0)
+        base_salary = float(self.get("base_salary", 0.0))
+        additional_pay = float(self.get("additional_pay", 0.0))
+        total_deduction = float(self.get("total_deduction", 0.0))
 
         self.total_payable = (
             base_salary + additional_pay + total_bonus - total_deduction
@@ -113,8 +94,5 @@
         if self.total_payable is None:
             self.total_payable = 0.0
 
-        if isinstance(self.total_payable, float | int):
-            self.total_payable = round(self.total_payable, 2)
-
-    # Другие методы жизненного цикла (before_save, on_submit, etc.) могут быть добавлены по необходимости.
-    # before_save: Логика расчета total_payable находится в custom_logic.payroll_entry_hooks.before_save
+        if isinstance(self.total_payable, (float, int)):
+            self.total_payable = round(self.total_payable, 2)