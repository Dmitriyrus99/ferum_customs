--- a/testvenv/lib/python3.12/site-packages/pip/_vendor/truststore/_windows.py
+++ b/testvenv/lib/python3.12/site-packages/pip/_vendor/truststore/_windows.py
@@ -1,8 +1,7 @@
 import contextlib
 import ssl
 import typing
-from ctypes import WinDLL  # type: ignore
-from ctypes import WinError  # type: ignore
+from ctypes import WinDLL, WinError
 from ctypes import (
     POINTER,
     Structure,
@@ -82,7 +81,7 @@
 
 
 if TYPE_CHECKING:
-    PCERT_CHAIN_PARA = pointer[CERT_CHAIN_PARA]  # type: ignore[misc]
+    PCERT_CHAIN_PARA = POINTER(CERT_CHAIN_PARA)
 else:
     PCERT_CHAIN_PARA = POINTER(CERT_CHAIN_PARA)
 
@@ -217,7 +216,6 @@
 FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000
 FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200
 
-# Flags to set for SSLContext.verify_mode=CERT_NONE
 CERT_CHAIN_POLICY_VERIFY_MODE_NONE_FLAGS = (
     CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS
     | CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG
@@ -236,7 +234,6 @@
 
 def _handle_win_error(result: bool, _: Any, args: Any) -> Any:
     if not result:
-        # Note, actually raises OSError after calling GetLastError and FormatMessage
         raise WinError()
     return args
 
@@ -324,11 +321,9 @@
     cert_chain: list[bytes],
     server_hostname: str | None = None,
 ) -> None:
-    """Verify the cert_chain from the server using Windows APIs."""
     pCertContext = None
     hIntermediateCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY, 0, None, 0, None)
     try:
-        # Add intermediate certs to an in-memory cert store
         for cert_bytes in cert_chain[1:]:
             CertAddEncodedCertificateToStore(
                 hIntermediateCertStore,
@@ -339,13 +334,11 @@
                 None,
             )
 
-        # Cert context for leaf cert
         leaf_cert = cert_chain[0]
         pCertContext = CertCreateCertificateContext(
             X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, leaf_cert, len(leaf_cert)
         )
 
-        # Chain params to match certs for serverAuth extended usage
         cert_enhkey_usage = CERT_ENHKEY_USAGE()
         cert_enhkey_usage.cUsageIdentifier = 1
         cert_enhkey_usage.rgpszUsageIdentifier = (c_char_p * 1)(OID_PKIX_KP_SERVER_AUTH)
@@ -364,8 +357,6 @@
             chain_flags = 0
 
         try:
-            # First attempt to verify using the default Windows system trust roots
-            # (default chain engine).
             _get_and_verify_cert_chain(
                 ssl_context,
                 None,
@@ -376,10 +367,6 @@
                 chain_flags=chain_flags,
             )
         except ssl.SSLCertVerificationError:
-            # If that fails but custom CA certs have been added
-            # to the SSLContext using load_verify_locations,
-            # try verifying using a custom chain engine
-            # that trusts the custom CA certs.
             custom_ca_certs: list[bytes] | None = ssl_context.get_ca_certs(
                 binary_form=True
             )
@@ -406,27 +393,25 @@
     hChainEngine: HCERTCHAINENGINE | None,
     hIntermediateCertStore: HCERTSTORE,
     pPeerCertContext: c_void_p,
-    pChainPara: PCERT_CHAIN_PARA,  # type: ignore[valid-type]
+    pChainPara: PCERT_CHAIN_PARA,
     server_hostname: str | None,
     chain_flags: int,
 ) -> None:
     ppChainContext = None
     try:
-        # Get cert chain
         ppChainContext = pointer(PCERT_CHAIN_CONTEXT())
         CertGetCertificateChain(
-            hChainEngine,  # chain engine
-            pPeerCertContext,  # leaf cert context
-            None,  # current system time
-            hIntermediateCertStore,  # additional in-memory cert store
-            pChainPara,  # chain-building parameters
+            hChainEngine,
+            pPeerCertContext,
+            None,
+            hIntermediateCertStore,
+            pChainPara,
             chain_flags,
-            None,  # reserved
-            ppChainContext,  # the resulting chain context
+            None,
+            ppChainContext,
         )
         pChainContext = ppChainContext.contents
 
-        # Verify cert chain
         ssl_extra_cert_chain_policy_para = SSL_EXTRA_CERT_CHAIN_POLICY_PARA()
         ssl_extra_cert_chain_policy_para.cbSize = sizeof(
             ssl_extra_cert_chain_policy_para
@@ -457,10 +442,8 @@
             pPolicyStatus,
         )
 
-        # Check status
         error_code = policy_status.dwError
         if error_code:
-            # Try getting a human readable message for an error code.
             error_message_buf = create_unicode_buffer(1024)
             error_message_chars = FormatMessageW(
                 FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
@@ -472,9 +455,6 @@
                 None,
             )
 
-            # See if we received a message for the error,
-            # otherwise we use a generic error with the
-            # error code and hope that it's search-able.
             if error_message_chars <= 0:
                 error_message = f"Certificate chain policy error {error_code:#x} [{policy_status.lElementIndex}]"
             else:
@@ -494,14 +474,13 @@
     custom_ca_certs: list[bytes],
     hIntermediateCertStore: HCERTSTORE,
     pPeerCertContext: c_void_p,
-    pChainPara: PCERT_CHAIN_PARA,  # type: ignore[valid-type]
+    pChainPara: PCERT_CHAIN_PARA,
     server_hostname: str | None,
     chain_flags: int,
 ) -> None:
     hChainEngine = None
     hRootCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY, 0, None, 0, None)
     try:
-        # Add custom CA certs to an in-memory cert store
         for cert_bytes in custom_ca_certs:
             CertAddEncodedCertificateToStore(
                 hRootCertStore,
@@ -512,8 +491,6 @@
                 None,
             )
 
-        # Create a custom cert chain engine which exclusively trusts
-        # certs from our hRootCertStore
         cert_chain_engine_config = CERT_CHAIN_ENGINE_CONFIG()
         cert_chain_engine_config.cbSize = sizeof(cert_chain_engine_config)
         cert_chain_engine_config.hExclusiveRoot = hRootCertStore
@@ -525,7 +502,6 @@
         )
         hChainEngine = phChainEngine.contents
 
-        # Get and verify a cert chain using the custom chain engine
         _get_and_verify_cert_chain(
             ssl_context,
             hChainEngine,
@@ -551,4 +527,4 @@
         yield
     finally:
         ctx.check_hostname = check_hostname
-        _set_ssl_context_verify_mode(ctx, verify_mode)
+        _set_ssl_context_verify_mode(ctx, verify_mode)
