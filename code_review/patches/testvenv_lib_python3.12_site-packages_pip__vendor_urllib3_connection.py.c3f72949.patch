--- a/testvenv/lib/python3.12/site-packages/pip/_vendor/urllib3/connection.py
+++ b/testvenv/lib/python3.12/site-packages/pip/_vendor/urllib3/connection.py
@@ -26,19 +26,15 @@
 
 
 try:
-    # Python 3: not a no-op, we're adding this to the namespace so it can be imported.
     ConnectionError = ConnectionError
 except NameError:
-    # Python 2
     class ConnectionError(Exception):
         pass
 
 
-try:  # Python 3:
-    # Not a no-op, we're adding this to the namespace so it can be imported.
+try:
     BrokenPipeError = BrokenPipeError
-except NameError:  # Python 2:
-
+except NameError:
     class BrokenPipeError(Exception):
         pass
 
@@ -66,64 +62,28 @@
 
 port_by_scheme = {"http": 80, "https": 443}
 
-# When it comes time to update this value as a part of regular maintenance
-# (ie test_recent_date is failing) update it to ~6 months before the current date.
 RECENT_DATE = datetime.date(2022, 1, 1)
 
 _CONTAINS_CONTROL_CHAR_RE = re.compile(r"[^-!#$%&'*+.^_`|~0-9a-zA-Z]")
 
 
 class HTTPConnection(_HTTPConnection, object):
-    """
-    Based on :class:`http.client.HTTPConnection` but provides an extra constructor
-    backwards-compatibility layer between older and newer Pythons.
-
-    Additional keyword parameters are used to configure attributes of the connection.
-    Accepted parameters include:
-
-    - ``strict``: See the documentation on :class:`urllib3.connectionpool.HTTPConnectionPool`
-    - ``source_address``: Set the source address for the current connection.
-    - ``socket_options``: Set specific options on the underlying socket. If not specified, then
-      defaults are loaded from ``HTTPConnection.default_socket_options`` which includes disabling
-      Nagle's algorithm (sets TCP_NODELAY to 1) unless the connection is behind a proxy.
-
-      For example, if you wish to enable TCP Keep Alive in addition to the defaults,
-      you might pass:
-
-      .. code-block:: python
-
-         HTTPConnection.default_socket_options + [
-             (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1),
-         ]
-
-      Or you may want to disable the defaults by passing an empty list (e.g., ``[]``).
-    """
-
     default_port = port_by_scheme["http"]
 
-    #: Disable Nagle's algorithm by default.
-    #: ``[(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)]``
     default_socket_options = [(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)]
 
-    #: Whether this connection verifies the host's certificate.
     is_verified = False
 
-    #: Whether this proxy connection (if used) verifies the proxy host's
-    #: certificate.
     proxy_is_verified = None
 
     def __init__(self, *args, **kw):
         if not six.PY2:
             kw.pop("strict", None)
 
-        # Pre-set source_address.
         self.source_address = kw.get("source_address")
 
-        #: The socket options provided by the user. If no options are
-        #: provided, we use the default options.
         self.socket_options = kw.pop("socket_options", self.default_socket_options)
 
-        # Proxy options provided by the user.
         self.proxy = kw.pop("proxy", None)
         self.proxy_config = kw.pop("proxy_config", None)
 
@@ -131,38 +91,13 @@
 
     @property
     def host(self):
-        """
-        Getter method to remove any trailing dots that indicate the hostname is an FQDN.
-
-        In general, SSL certificates don't include the trailing dot indicating a
-        fully-qualified domain name, and thus, they don't validate properly when
-        checked against a domain name that includes the dot. In addition, some
-        servers may not expect to receive the trailing dot when provided.
-
-        However, the hostname with trailing dot is critical to DNS resolution; doing a
-        lookup with the trailing dot will properly only resolve the appropriate FQDN,
-        whereas a lookup without a trailing dot will search the system's search domain
-        list. Thus, it's important to keep the original host around for use only in
-        those cases where it's appropriate (i.e., when doing DNS lookup to establish the
-        actual TCP connection across which we're going to send HTTP requests).
-        """
         return self._dns_host.rstrip(".")
 
     @host.setter
     def host(self, value):
-        """
-        Setter for the `host` property.
-
-        We assume that only urllib3 uses the _dns_host attribute; httplib itself
-        only uses `host`, and it seems reasonable that other libraries follow suit.
-        """
         self._dns_host = value
 
     def _new_conn(self):
-        """Establish a socket connection and set nodelay settings on it.
-
-        :return: New socket connection.
-        """
         extra_kw = {}
         if self.source_address:
             extra_kw["source_address"] = self.source_address
@@ -190,15 +125,12 @@
         return conn
 
     def _is_using_tunnel(self):
-        # Google App Engine's httplib does not define _tunnel_host
         return getattr(self, "_tunnel_host", None)
 
     def _prepare_conn(self, conn):
         self.sock = conn
         if self._is_using_tunnel():
-            # TODO: Fix tunnel so it doesn't depend on self.sock state.
             self._tunnel()
-            # Mark this connection as not reusable
             self.auto_open = 0
 
     def connect(self):
@@ -206,9 +138,6 @@
         self._prepare_conn(conn)
 
     def putrequest(self, method, url, *args, **kwargs):
-        """ """
-        # Empty docstring because the indentation of CPython's implementation
-        # is broken but we don't want this method in our documentation.
         match = _CONTAINS_CONTROL_CHAR_RE.search(method)
         if match:
             raise ValueError(
@@ -219,7 +148,6 @@
         return _HTTPConnection.putrequest(self, method, url, *args, **kwargs)
 
     def putheader(self, header, *values):
-        """ """
         if not any(isinstance(v, str) and v == SKIP_HEADER for v in values):
             _HTTPConnection.putheader(self, header, *values)
         elif six.ensure_str(header.lower()) not in SKIPPABLE_HEADERS:
@@ -229,25 +157,18 @@
             )
 
     def request(self, method, url, body=None, headers=None):
-        # Update the inner socket's timeout value to send the request.
-        # This only triggers if the connection is re-used.
         if getattr(self, "sock", None) is not None:
             self.sock.settimeout(self.timeout)
 
         if headers is None:
             headers = {}
         else:
-            # Avoid modifying the headers passed into .request()
             headers = headers.copy()
         if "user-agent" not in (six.ensure_str(k.lower()) for k in headers):
             headers["User-Agent"] = _get_default_user_agent()
         super(HTTPConnection, self).request(method, url, body=body, headers=headers)
 
     def request_chunked(self, method, url, body=None, headers=None):
-        """
-        Alternative to the common request method, which sends the
-        body with chunked encoding and not as one block
-        """
         headers = headers or {}
         header_keys = set([six.ensure_str(k.lower()) for k in headers])
         skip_accept_encoding = "accept-encoding" in header_keys
@@ -279,16 +200,10 @@
                 to_send += b"\r\n"
                 self.send(to_send)
 
-        # After the if clause, to always have a closed body
         self.send(b"0\r\n\r\n")
 
 
 class HTTPSConnection(HTTPConnection):
-    """
-    Many of the parameters to this constructor are passed to the underlying SSL
-    socket by means of :py:func:`urllib3.util.ssl_wrap_socket`.
-    """
-
     default_port = port_by_scheme["https"]
 
     cert_reqs = None
@@ -321,8 +236,6 @@
         self.ssl_context = ssl_context
         self.server_hostname = server_hostname
 
-        # Required property for Google AppEngine 1.9.0 which otherwise causes
-        # HTTPS requests to go out as HTTP. (See Issue #356)
         self._protocol = "https"
 
     def set_cert(
@@ -337,11 +250,6 @@
         ca_cert_dir=None,
         ca_cert_data=None,
     ):
-        """
-        This method should only be called once, before the connection is used.
-        """
-        # If cert_reqs is not provided we'll assume CERT_REQUIRED unless we also
-        # have an SSLContext object in which case we'll use its verify_mode.
         if cert_reqs is None:
             if self.ssl_context is not None:
                 cert_reqs = self.ssl_context.verify_mode
@@ -359,7 +267,6 @@
         self.ca_cert_data = ca_cert_data
 
     def connect(self):
-        # Add certificate verification
         self.sock = conn = self._new_conn()
         hostname = self.host
         tls_in_tls = False
@@ -369,13 +276,9 @@
                 self.sock = conn = self._connect_tls_proxy(hostname, conn)
                 tls_in_tls = True
 
-            # Calls self._set_hostport(), so self.host is
-            # self._tunnel_host below.
             self._tunnel()
-            # Mark this connection as not reusable
             self.auto_open = 0
 
-            # Override the host with the one we're requesting data from.
             hostname = self._tunnel_host
 
         server_hostname = hostname
@@ -392,8 +295,6 @@
                 SystemTimeWarning,
             )
 
-        # Wrap socket using verification with the root certs in
-        # trusted_root_certs
         default_ssl_context = False
         if self.ssl_context is None:
             default_ssl_context = True
@@ -405,8 +306,6 @@
         context = self.ssl_context
         context.verify_mode = resolve_cert_reqs(self.cert_reqs)
 
-        # Try to load OS default certs if none are given.
-        # Works well on Windows (requires Python3.4+)
         if (
             not self.ca_certs
             and not self.ca_cert_dir
@@ -429,9 +328,6 @@
             tls_in_tls=tls_in_tls,
         )
 
-        # If we're using all defaults and the connection
-        # is TLSv1 or TLSv1.1 we throw a DeprecationWarning
-        # for the host.
         if (
             default_ssl_context
             and self.ssl_version is None
@@ -455,9 +351,6 @@
             and not getattr(context, "check_hostname", False)
             and self.assert_hostname is not False
         ):
-            # While urllib3 attempts to always turn off hostname matching from
-            # the TLS library, this cannot always be done. So we check whether
-            # the TLS Library still thinks it's matching hostnames.
             cert = self.sock.getpeercert()
             if not cert.get("subjectAltName", ()):
                 warnings.warn(
@@ -477,14 +370,9 @@
         )
 
     def _connect_tls_proxy(self, hostname, conn):
-        """
-        Establish a TLS connection to the proxy using the provided SSL context.
-        """
         proxy_config = self.proxy_config
         ssl_context = proxy_config.ssl_context
         if ssl_context:
-            # If the user provided a proxy context, we assume CA and client
-            # certificates have already been set
             return ssl_wrap_socket(
                 sock=conn,
                 server_hostname=hostname,
@@ -499,8 +387,6 @@
             self.ca_cert_data,
         )
 
-        # If no cert was provided, use only the default options for server
-        # certificate validation
         socket = ssl_wrap_socket(
             sock=conn,
             ca_certs=self.ca_certs,
@@ -513,9 +399,6 @@
         if ssl_context.verify_mode != ssl.CERT_NONE and not getattr(
             ssl_context, "check_hostname", False
         ):
-            # While urllib3 attempts to always turn off hostname matching from
-            # the TLS library, this cannot always be done. So we check whether
-            # the TLS Library still thinks it's matching hostnames.
             cert = socket.getpeercert()
             if not cert.get("subjectAltName", ()):
                 warnings.warn(
@@ -534,9 +417,6 @@
 
 
 def _match_hostname(cert, asserted_hostname):
-    # Our upstream implementation of ssl.match_hostname()
-    # only applies this normalization to IP addresses so it doesn't
-    # match DNS SANs so we do the same thing!
     stripped_hostname = asserted_hostname.strip("u[]")
     if is_ipaddress(stripped_hostname):
         asserted_hostname = stripped_hostname
@@ -549,8 +429,6 @@
             asserted_hostname,
             cert,
         )
-        # Add cert to exception and reraise so client code can inspect
-        # the cert when catching the exception, if they want to
         e._peer_cert = cert
         raise
 
@@ -560,8 +438,6 @@
 
 
 class DummyConnection(object):
-    """Used to detect a failed ConnectionCls import."""
-
     pass
 
 
@@ -569,4 +445,4 @@
     HTTPSConnection = DummyConnection  # noqa: F811
 
 
-VerifiedHTTPSConnection = HTTPSConnection
+VerifiedHTTPSConnection = HTTPSConnection
