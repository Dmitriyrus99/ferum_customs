--- a/testvenv/lib/python3.12/site-packages/pip/_vendor/truststore/_macos.py
+++ b/testvenv/lib/python3.12/site-packages/pip/_vendor/truststore/_macos.py
@@ -29,9 +29,7 @@
 def _load_cdll(name: str, macos10_16_path: str) -> CDLL:
     """Loads a CDLL by name, falling back to known path on 10.16+"""
     try:
-        # Big Sur is technically 11 but we use 10.16 due to the Big Sur
-        # beta being labeled as 10.16.
-        path: str | None
+        path: typing.Optional[str]
         if _mac_version_info >= (10, 16):
             path = macos10_16_path
         else:
@@ -211,14 +209,10 @@
     if int(result) == 0:
         return args
 
-    # Returns a CFString which we need to transform
-    # into a UTF-8 Python string.
     error_message_cfstring = None
     try:
         error_message_cfstring = Security.SecCopyErrorMessageString(result, None)
 
-        # First step is convert the CFString into a C string pointer.
-        # We try the fast no-copy way first.
         error_message_cfstring_c_void_p = ctypes.cast(
             error_message_cfstring, ctypes.POINTER(ctypes.c_void_p)
         )
@@ -226,13 +220,6 @@
             error_message_cfstring_c_void_p, CFConst.kCFStringEncodingUTF8
         )
 
-        # Quoting the Apple dev docs:
-        #
-        # "A pointer to a C string or NULL if the internal
-        # storage of theString does not allow this to be
-        # returned efficiently."
-        #
-        # So we need to get our hands dirty.
         if message is None:
             buffer = ctypes.create_string_buffer(1024)
             result = CoreFoundation.CFStringGetCString(
@@ -249,8 +236,6 @@
         if error_message_cfstring is not None:
             CoreFoundation.CFRelease(error_message_cfstring)
 
-    # If no message can be found for this status we come
-    # up with a generic one that forwards the status code.
     if message is None or message == "":
         message = f"SecureTransport operation returned a non-zero OSStatus: {result}"
 
@@ -293,11 +278,10 @@
     return cf_str  # type: ignore[no-any-return]
 
 
-def _cf_string_ref_to_str(cf_string_ref: CFStringRef) -> str | None:  # type: ignore[valid-type]
+def _cf_string_ref_to_str(cf_string_ref: CFStringRef) -> typing.Optional[str]:  # type: ignore[valid-type]
     """
     Creates a Unicode string from a CFString object. Used entirely for error
     reporting.
-    Yes, it annoys me quite a lot that this function is this complex.
     """
 
     string = CoreFoundation.CFStringGetCStringPtr(
@@ -316,7 +300,7 @@
     return string  # type: ignore[no-any-return]
 
 
-def _der_certs_to_cf_cert_array(certs: list[bytes]) -> CFMutableArrayRef:  # type: ignore[valid-type]
+def _der_certs_to_cf_cert_array(certs: typing.List[bytes]) -> CFMutableArrayRef:  # type: ignore[valid-type]
     """Builds a CFArray of SecCertificateRefs from a list of DER-encoded certificates.
     Responsibility of the caller to call CoreFoundation.CFRelease on the CFArray.
     """
@@ -361,8 +345,8 @@
 
 def _verify_peercerts_impl(
     ssl_context: ssl.SSLContext,
-    cert_chain: list[bytes],
-    server_hostname: str | None = None,
+    cert_chain: typing.List[bytes],
+    server_hostname: typing.Optional[str] = None,
 ) -> None:
     certs = None
     policies = None
@@ -382,7 +366,6 @@
 
         policies = ssl_policy
         if ssl_context.verify_flags & ssl.VERIFY_CRL_CHECK_CHAIN:
-            # Add explicit policy requiring positive revocation checks
             policies = CoreFoundation.CFArrayCreateMutable(
                 CoreFoundation.kCFAllocatorDefault,
                 0,
@@ -403,29 +386,22 @@
         try:
             certs = _der_certs_to_cf_cert_array(cert_chain)
 
-            # Now that we have certificates loaded and a SecPolicy
-            # we can finally create a SecTrust object!
             trust = Security.SecTrustRef()
             Security.SecTrustCreateWithCertificates(
                 certs, policies, ctypes.byref(trust)
             )
 
         finally:
-            # The certs are now being held by SecTrust so we can
-            # release our handles for the array.
             if certs:
                 CoreFoundation.CFRelease(certs)
 
-        # If there are additional trust anchors to load we need to transform
-        # the list of DER-encoded certificates into a CFArray. Otherwise
-        # pass 'None' to signal that we only want system / fetched certificates.
-        ctx_ca_certs_der: list[bytes] | None = ssl_context.get_ca_certs(
+        ctx_ca_certs_der: typing.Optional[typing.List[bytes]] = ssl_context.get_ca_certs(
             binary_form=True
         )
         if ctx_ca_certs_der:
             ctx_ca_certs = None
             try:
-                ctx_ca_certs = _der_certs_to_cf_cert_array(cert_chain)
+                ctx_ca_certs = _der_certs_to_cf_cert_array(ctx_ca_certs_der)
                 Security.SecTrustSetAnchorCertificates(trust, ctx_ca_certs)
             finally:
                 if ctx_ca_certs:
@@ -437,8 +413,6 @@
         sec_trust_eval_result = Security.SecTrustEvaluateWithError(
             trust, ctypes.byref(cf_error)
         )
-        # sec_trust_eval_result is a bool (0 or 1)
-        # where 1 means that the certs are trusted.
         if sec_trust_eval_result == 1:
             is_trusted = True
         elif sec_trust_eval_result == 0:
@@ -452,9 +426,6 @@
         if not is_trusted:
             cf_error_code = CoreFoundation.CFErrorGetCode(cf_error)
 
-            # If the error is a known failure that we're
-            # explicitly okay with from SSLContext configuration
-            # we can set is_trusted accordingly.
             if ssl_context.verify_mode != ssl.CERT_REQUIRED and (
                 cf_error_code == CFConst.errSecNotTrusted
                 or cf_error_code == CFConst.errSecCertificateExpired
@@ -466,21 +437,16 @@
             ):
                 is_trusted = True
 
-        # If we're still not trusted then we start to
-        # construct and raise the SSLCertVerificationError.
         if not is_trusted:
             cf_error_string_ref = None
             try:
                 cf_error_string_ref = CoreFoundation.CFErrorCopyDescription(cf_error)
 
-                # Can this ever return 'None' if there's a CFError?
                 cf_error_message = (
                     _cf_string_ref_to_str(cf_error_string_ref)
                     or "Certificate verification failed"
                 )
 
-                # TODO: Not sure if we need the SecTrustResultType for anything?
-                # We only care whether or not it's a success or failure for now.
                 sec_trust_result_type = Security.SecTrustResultType()
                 Security.SecTrustGetTrustResult(
                     trust, ctypes.byref(sec_trust_result_type)
@@ -498,4 +464,4 @@
         if policies:
             CoreFoundation.CFRelease(policies)
         if trust:
-            CoreFoundation.CFRelease(trust)
+            CoreFoundation.CFRelease(trust)
