--- a/testvenv/lib/python3.12/site-packages/pip/_vendor/urllib3/packages/backports/weakref_finalize.py
+++ b/testvenv/lib/python3.12/site-packages/pip/_vendor/urllib3/packages/backports/weakref_finalize.py
@@ -26,10 +26,6 @@
     By default atexit is true.
     """
 
-    # Finalizer objects don't have any state of their own.  They are
-    # just used as keys to lookup _Info objects in the registry.  This
-    # ensures that they cannot be part of a ref-cycle.
-
     __slots__ = ()
     _registry = {}
     _shutdown = False
@@ -42,10 +38,7 @@
 
     def __init__(self, obj, func, *args, **kwargs):
         if not self._registered_with_atexit:
-            # We may register the exit function more than once because
-            # of a thread race, but that is harmless
             import atexit
-
             atexit.register(self._exitfunc)
             weakref_finalize._registered_with_atexit = True
         info = self._Info()
@@ -59,23 +52,17 @@
         weakref_finalize._dirty = True
 
     def __call__(self, _=None):
-        """If alive then mark as dead and return func(*args, **kwargs);
-        otherwise return None"""
         info = self._registry.pop(self, None)
         if info and not self._shutdown:
             return info.func(*info.args, **(info.kwargs or {}))
 
     def detach(self):
-        """If alive then mark as dead and return (obj, func, args, kwargs);
-        otherwise return None"""
         info = self._registry.get(self)
         obj = info and info.weakref()
         if obj is not None and self._registry.pop(self, None):
             return (obj, info.func, info.args, info.kwargs or {})
 
     def peek(self):
-        """If alive then return (obj, func, args, kwargs);
-        otherwise return None"""
         info = self._registry.get(self)
         obj = info and info.weakref()
         if obj is not None:
@@ -83,12 +70,10 @@
 
     @property
     def alive(self):
-        """Whether finalizer is alive"""
         return self in self._registry
 
     @property
     def atexit(self):
-        """Whether finalizer should be called at exit"""
         info = self._registry.get(self)
         return bool(info) and info.atexit
 
@@ -113,16 +98,12 @@
 
     @classmethod
     def _select_for_exit(cls):
-        # Return live finalizers marked for exit, oldest first
         L = [(f, i) for (f, i) in cls._registry.items() if i.atexit]
         L.sort(key=lambda item: item[1].index)
         return [f for (f, i) in L]
 
     @classmethod
     def _exitfunc(cls):
-        # At shutdown invoke finalizers for which atexit is true.
-        # This is called once all other non-daemonic threads have been
-        # joined.
         reenable_gc = False
         try:
             if cls._registry:
@@ -140,16 +121,11 @@
                         break
                     f = pending.pop()
                     try:
-                        # gc is disabled, so (assuming no daemonic
-                        # threads) the following is the only line in
-                        # this function which might trigger creation
-                        # of a new finalizer
                         f()
                     except Exception:
                         sys.excepthook(*sys.exc_info())
                     assert f not in cls._registry
         finally:
-            # prevent any more finalizers from executing during shutdown
             weakref_finalize._shutdown = True
             if reenable_gc:
-                gc.enable()
+                gc.enable()
