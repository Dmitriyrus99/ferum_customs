--- a/testvenv/lib/python3.12/site-packages/pip/_vendor/tenacity/retry.py
+++ b/testvenv/lib/python3.12/site-packages/pip/_vendor/tenacity/retry.py
@@ -1,19 +1,3 @@
-# Copyright 2016â€“2021 Julien Danjou
-# Copyright 2016 Joshua Harlow
-# Copyright 2013-2014 Ray Holder
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
 import abc
 import re
 import typing
@@ -30,9 +14,13 @@
         pass
 
     def __and__(self, other: "retry_base") -> "retry_all":
+        if not isinstance(other, retry_base):
+            raise TypeError("Operand must be an instance of retry_base")
         return retry_all(self, other)
 
     def __or__(self, other: "retry_base") -> "retry_any":
+        if not isinstance(other, retry_base):
+            raise TypeError("Operand must be an instance of retry_base")
         return retry_any(self, other)
 
 
@@ -88,6 +76,8 @@
             typing.Tuple[typing.Type[BaseException], ...],
         ] = Exception,
     ) -> None:
+        if not isinstance(exception_types, (type, tuple)):
+            raise TypeError("exception_types must be a type or tuple of types")
         self.exception_types = exception_types
         super().__init__(lambda e: isinstance(e, exception_types))
 
@@ -102,6 +92,8 @@
             typing.Tuple[typing.Type[BaseException], ...],
         ] = Exception,
     ) -> None:
+        if not isinstance(exception_types, (type, tuple)):
+            raise TypeError("exception_types must be a type or tuple of types")
         self.exception_types = exception_types
         super().__init__(lambda e: not isinstance(e, exception_types))
 
@@ -116,6 +108,8 @@
             typing.Tuple[typing.Type[BaseException], ...],
         ] = Exception,
     ) -> None:
+        if not isinstance(exception_types, (type, tuple)):
+            raise TypeError("exception_types must be a type or tuple of types")
         self.exception_types = exception_types
         super().__init__(lambda e: not isinstance(e, exception_types))
 
@@ -147,6 +141,8 @@
             typing.Tuple[typing.Type[BaseException], ...],
         ] = Exception,
     ) -> None:
+        if not isinstance(exception_types, (type, tuple)):
+            raise TypeError("exception_types must be a type or tuple of types")
         self.exception_cause_types = exception_types
 
     def __call__(self, retry_state: "RetryCallState") -> bool:
@@ -260,6 +256,8 @@
     """Retries if any of the retries condition is valid."""
 
     def __init__(self, *retries: retry_base) -> None:
+        if not all(isinstance(r, retry_base) for r in retries):
+            raise TypeError("All arguments must be instances of retry_base")
         self.retries = retries
 
     def __call__(self, retry_state: "RetryCallState") -> bool:
@@ -270,7 +268,9 @@
     """Retries if all the retries condition are valid."""
 
     def __init__(self, *retries: retry_base) -> None:
+        if not all(isinstance(r, retry_base) for r in retries):
+            raise TypeError("All arguments must be instances of retry_base")
         self.retries = retries
 
     def __call__(self, retry_state: "RetryCallState") -> bool:
-        return all(r(retry_state) for r in self.retries)
+        return all(r(retry_state) for r in self.retries)
