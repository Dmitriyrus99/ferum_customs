--- a/testvenv/lib/python3.12/site-packages/pip/_vendor/pyparsing/exceptions.py
+++ b/testvenv/lib/python3.12/site-packages/pip/_vendor/pyparsing/exceptions.py
@@ -13,7 +13,7 @@
 
 
 _extract_alphanums = _collapse_string_to_ranges(ExceptionWordUnicode.alphanums)
-_exception_word_extractor = re.compile("([" + _extract_alphanums + "]{1,16})|.")
+_exception_word_extractor = re.compile("([" + re.escape(_extract_alphanums) + "]{1,16})|.")  # Escape special characters
 
 
 class ParseBaseException(Exception):
@@ -33,8 +33,6 @@
         "args",
     )
 
-    # Performance tuning: we construct a *lot* of these, so keep this
-    # constructor as small and fast as possible
     def __init__(
         self,
         pstr: str,
@@ -54,21 +52,6 @@
 
     @staticmethod
     def explain_exception(exc, depth=16):
-        """
-        Method to take an exception and translate the Python internal traceback into a list
-        of the pyparsing expressions that caused the exception to be raised.
-
-        Parameters:
-
-        - exc - exception raised during parsing (need not be a ParseException, in support
-          of Python exceptions that might be raised in a parse action)
-        - depth (default=16) - number of levels back in the stack trace to list expression
-          and function names; if None, the full stack trace names will be listed; if 0, only
-          the failing input line, marker, and exception string will be shown
-
-        Returns a multi-line string listing the ParserElements and/or function names in the
-        exception's stack trace.
-        """
         import inspect
 
         from .core import ParserElement
@@ -121,41 +104,24 @@
 
     @classmethod
     def _from_exception(cls, pe):
-        """
-        internal factory method to simplify creating one type of ParseException
-        from another - avoids having __init__ signature conflicts among subclasses
-        """
         return cls(pe.pstr, pe.loc, pe.msg, pe.parser_element)
 
     @property
     def line(self) -> str:
-        """
-        Return the line of text where the exception occurred.
-        """
         return line(self.loc, self.pstr)
 
     @property
     def lineno(self) -> int:
-        """
-        Return the 1-based line number of text where the exception occurred.
-        """
         return lineno(self.loc, self.pstr)
 
     @property
     def col(self) -> int:
-        """
-        Return the 1-based column on the line of text where the exception occurred.
-        """
         return col(self.loc, self.pstr)
 
     @property
     def column(self) -> int:
-        """
-        Return the 1-based column on the line of text where the exception occurred.
-        """
         return col(self.loc, self.pstr)
 
-    # pre-PEP8 compatibility
     @property
     def parserElement(self):
         return self.parser_element
@@ -169,7 +135,6 @@
             if self.loc >= len(self.pstr):
                 foundstr = ", found end of text"
             else:
-                # pull out next word at error location
                 found_match = _exception_word_extractor.match(self.pstr, self.loc)
                 if found_match is not None:
                     found = found_match.group(0)
@@ -186,10 +151,6 @@
     def mark_input_line(
         self, marker_string: typing.Optional[str] = None, *, markerString: str = ">!<"
     ) -> str:
-        """
-        Extracts the exception line from the input string, and marks
-        the location of the exception with a special symbol.
-        """
         markerString = marker_string if marker_string is not None else markerString
         line_str = self.line
         line_column = self.column - 1
@@ -200,67 +161,15 @@
         return line_str.strip()
 
     def explain(self, depth=16) -> str:
-        """
-        Method to translate the Python internal traceback into a list
-        of the pyparsing expressions that caused the exception to be raised.
-
-        Parameters:
-
-        - depth (default=16) - number of levels back in the stack trace to list expression
-          and function names; if None, the full stack trace names will be listed; if 0, only
-          the failing input line, marker, and exception string will be shown
-
-        Returns a multi-line string listing the ParserElements and/or function names in the
-        exception's stack trace.
-
-        Example::
-
-            expr = pp.Word(pp.nums) * 3
-            try:
-                expr.parse_string("123 456 A789")
-            except pp.ParseException as pe:
-                print(pe.explain(depth=0))
-
-        prints::
-
-            123 456 A789
-                    ^
-            ParseException: Expected W:(0-9), found 'A'  (at char 8), (line:1, col:9)
-
-        Note: the diagnostic output will include string representations of the expressions
-        that failed to parse. These representations will be more helpful if you use `set_name` to
-        give identifiable names to your expressions. Otherwise they will use the default string
-        forms, which may be cryptic to read.
-
-        Note: pyparsing's default truncation of exception tracebacks may also truncate the
-        stack of expressions that are displayed in the ``explain`` output. To get the full listing
-        of parser expressions, you may have to set ``ParserElement.verbose_stacktrace = True``
-        """
         return self.explain_exception(self, depth)
 
-    # fmt: off
     @replaced_by_pep8(mark_input_line)
     def markInputline(self): ...
-    # fmt: on
 
 
 class ParseException(ParseBaseException):
     """
     Exception thrown when a parse expression doesn't match the input string
-
-    Example::
-
-        try:
-            Word(nums).set_name("integer").parse_string("ABC")
-        except ParseException as pe:
-            print(pe)
-            print("column: {}".format(pe.column))
-
-    prints::
-
-       Expected integer (at char 0), (line:1, col:1)
-        column: 1
-
     """
 
 
@@ -291,4 +200,4 @@
         self.parseElementTrace = parseElementList
 
     def __str__(self) -> str:
-        return f"RecursiveGrammarException: {self.parseElementTrace}"
+        return f"RecursiveGrammarException: {self.parseElementTrace}"
